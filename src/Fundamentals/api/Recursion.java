package Fundamentals.api;

/**
 * 对递归最恰当的比喻，就是查词典。
 * 我们查词典的过程，本身就是递归。
 * 想象用一本纯英文词典查单词，要查某一个单词的意思，翻到这个单词时，看解释，发现解释中有一个单词不认识，
 * 所以，无法明白这个要查的单词是什么意思 * ；
 * 这时，再用这本词典（函数本身）查那个不认识的单词，又发现查的第2个单词的解释中又有一个单词不认识，那么，
 * 又再用这本词典查第3个不认识的单词，
 * 这样，一个一个查下去，直到解释中所有单词都认识，这样就到底了，就明白了最后一个单词是什么意思，
 * 然后一层一层倒回来，
 * 就知道我最初想查的第1个单词是什么意思了，问题就解决了。
 * <p>
 * 在需要将一项工作不断分为两项较小的、类似的工作时，递归非常有用。
 * 例如，请考虑使用这种方法来绘制标尺的情况。标出两端，找到中点并将其标出。
 * 然后将同样的操作作用于标尺的左半部分和右半部分。
 * 如果要进一步细分，可将同样的操作用于当前的每一部分。递归方法有时被称为分而治之策略。
 */
//void recurs(argumentlist){
//        statements1
//        if(test)　　　　　　//test最终为false，调用链将断开
//        recurs(arguments)
//        statements2
//        }

/**
 * 在需要将一项工作不断分为两项较小的、类似的工作时，递归非常有用。
 * 例如，请考虑使用这种方法来绘制标尺的情况。标出两端，找到中点并将其标出。
 * 然后将同样的操作作用于标尺的左半部分和右半部分。
 * 如果要进一步细分，可将同样的操作用于当前的每一部分。递归方法有时被称为分而治之策略。
 */

//有时候问题在去的路上就已经解决了
//recursion()
//        {
//        if (end_condition)
//        {
//        solve;
//        }
//        else
//        {     //在将问题转换为子问题描述的每一步，都解决该步中剩余部分的问题。
//        for () { recursion();     //go; }
//        }
//        }

/**
 * 对于递归的研究 递归是有去有回,去是描述问题,回是解决问题.
 * 区别于循环是,循环有去无回.因此循环符合人的思维.
 */
public class Recursion {
    private void test1(int n) {
        System.out.println("第" + n + "层" + this.hashCode());
        if (n > 0) {
            test1(n - 1);
        }
        System.out.println("执行完毕" + "\t" + n + "\t" + this.hashCode());
    }

    private int test2(int n) {
        if (n == 1 || n == 0) {
            return 1;
        }
        return test2(n - 1) + test2(n - 2);
    }

    public static void main(String[] args) {
        int i = new Recursion().test2(5);
        System.out.println(i);
    }
}
